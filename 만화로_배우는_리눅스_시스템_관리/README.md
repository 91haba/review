# 만화로 배우는 리눅스 시스템 관리 - Prio 지음 / 서수환 옮김 ([Yes24](http://www.yes24.com/24/goods/30705473))

![표지](./images/표지.jpg)

리눅스 환경에서 사용하는 명령어가 너무 단순하고 쓰던것만 쓴다는 생각에 
책 한권을 간단하게라도 훑어 봐야겠다는 생각에 선택한 책 <br/>
생각보다 내용이 알차다 (그만큼 내가 허접하니깐.... 후후..)

![후후...](./images/후후.jpg)

## 9화 명령어 이력 검색
* 명력어 이력 저장 갯수 수정
```
설정파일 열기 : vim ~/.bashrc
파일끝으로 이동 : shift + g
설정 추가
export HISTSIZE 1000
export HISTFILESIZE=10000
저장 및 반영
source ~/.bashrc
```

* 터미널마다의 명령 히스토리 공유
```
설정파일 열기 : vim ~/.bashrc
파일끝으로 이동 : shift + g
설정 추가
function share_history {
    history -a
    history -c
    history -r
}
PROMPT_COMMAND='share_history'
shopt -u histappend
```

## 10화 네트워크를 건너 파일 복사 (scp)

* 현재 PC의 파일을 반대편 PC로 보내는 경우 : 이쪽에 있는걸 저쪽으로 보낸다는 개념
```
scp 파일명 사용자계정@반대편 PC(네트워크명 또는 IP):복사될 디렉토리 위치

ex) scp ./file.txt jojoldu@192.168.1.10:/tmp/
```

* 반대편 PC의 파일을 현재 PC로 가져올 경우 : 저쪽에 있는걸 이쪽으로 가져온다는 개념
```
scp 사용자계정@반대편 PC(네트워크명 또는 IP):복사할 파일의 위치 현재PC경로(복사될 위치)

ex) scp jojoldu@192.168.1.10:/tmp/file.txt /data/
```

* 여러개 동시 복사
```
1. 와일드카드 사용 (/tmp/ 디렉토리에서 .txt로 끝나는 파일 모두)
ex) scp jojoldu@192.168.1.10:/tmp/*.txt /data/

2. 디렉토리 전체 복사(/tmp/ 디렉토리 전체 복사)
ex) scp -r jojoldu@192.168.1.10:/tmp/ /data/
```

* 다른 PC에서 다른 PC로 파일 복사
```
scp 사용자계정@반대편1:복사파일위치 사용자계정@반대편2:도착디렉토리

ex) scp jojoldu@192.168.1.10:/tmp/file.txt jojoldu@192.168.1.11:/data/
```

## 11화 시스템 부하를 파악하고 싶어 (top)
시스템 부하 관련 정보를 수초 간격으로 실시간으로 갱신파면서 표기해주는 명령어 <br/>
보고 싶은 서버에 접속해서 top만 입력하면 됨 <br/>
아래는 top 명령어로 출력되는 화면에서 확인해야할 내용들이다.

* load average 
  - CPU가 처리하는 걸 기다리는 작업 개수
  - CPU는 한 번에 하나밖에 처리 못하니, 그동안 발생한 새로운 작업은 쌓아둔다.
  - load average는 1분당 평균으로 몇 개의 일이 쌓이는지를 나타냄
  - **코어의 수에 따라 load average 부하**정도를 판단해야 한다. (load average >= cpu 코어수 : 과부하 상태)
  - 쿼드코어는 CPU가 4개이므로, 한 번에 4개의 일을 처리하니 load average는 4이하가 안전한 상태이다.
  

* %CPU / TIME+
  - %CPU 란 해당 프로세스사 차지하는 **CPU 사용율**이다.
  - TIME+ 란 실제로 **CPU를 사용한 시간**이다.
  - %CPU가 높아도 TIME+가 짧은 경우 해당 프로세스를 수행하는 시간이 짧고 휴식시간이 긴 형태이므로 실제 부하량은 낮다고 볼 수 있다.
  - 즉, 과부하 원인을 찾을때는 **CPU사용율이 높은지/CPU사용시간이 긴지**로 확인해야 한다.

* COMMAND
  - 프로세스를 실행했을 때 실행한 명령어를 표시
  - 해당 프로세스를 정말 멈춰도 되는지 확인을 위해 주로 본다.
  - top이 켜져있는 상태로 COMMAND의 약자인 "c"를 입력할 경우 상세 커맨드가 표시된다.

## 12화 시스템 메모리 부족을 파악하고 싶어 (top 표시 전환)
CPU 부하량이 낮아도 load average가 높은 경우가 있는데, 대표적인 예가 디스크 I/O이다. <br/>
> 하드디스크에 저장한 파일을 찾거나, 내용을 읽거나, 파일 저장이 끝날때까지 등등의 경우가 있다.

* Swap
  - 스왑 발생량
  - CPU는 메모리에서 작업을 진행하는데, 메모리 여유 공간이 부족하면 새로운 작업을 할 수 없다 (즉, 작업들이 대기시간에 빠진다.)
  - 스왑아웃 : OS에서 메모리 공간 확보를 위해 최근에 사용하지 않은 데이터를 하드디스크로 옮기는 행위
  - 스왑인 : 스왑아웃한 데이터가 필요해지면 하드디스크에서 메모리로 데이터를 되돌리는 행위
  - 스왑아웃 & 스왑인을 합쳐 스왑이라고 한다.
  - **메모리 사용량이 늘면 늘수록 스왑이 빈번하게 발생**해서 I/O 대기시간이 길어지며 load average가 높아지게 된다.
  - Swap가 높으면 스왑 발생량이 높아 load average가 높다는 이야기이다.
  - top의 정렬순서를 변경하고 싶을 경우
    - cpu 시간 순 : shift + t
    - cpu 사용량 순 : shift + p

* %MEM
  - 프로세스가 소비하는 메모리양
  - 전체 메모리 중 해당 프로세스가 몇 %의 메모리를 차지하는지 표시해준다.
  - top의 기본정렬은 CPU부하가 높은 순이라 메모리가 높은 순으로 정렬하고 싶을 경우 shift+m을 누르면 된다.

## 13화 로그 파일에서 필요한 줄만 뽑고 싶어 (파이프라인 |)
명령어의 실행 결과 출력을 그대로 다른 명령어에 넘겨주는 것 (shift+\ 눌렀을 때 나오는 | 를 말함) <br/>
보통은 grep와 함께 사용해서 로그파일에서 여러 조건을 사용한 조회시에 사용한다.

![파이프라인 느낌](./images/파이프라인.png)
(동시에 여러 파이프라인을 사용한 경우 대략 이런 느낌?)

```
출력을 넘기는 명령어 | 출력을 받을 명령어 | 출력을 받을 명령어 | 출력을 받을 명령어

ex) grep 'NullPointerException' /data/log/logback/20160914.log | less
```

* zcat
  - 압축 파일을 읽어서 내용을 풀어서 출력하는 명령어
  - 압축된 log파일을 읽을 때 자주 사용
  - 비슷한 형식으로 zxcat(.xz 압축파일), unzip(zip 압축파일)

* 실시간으로 조건 조회
  - tail : 파일 내용의 끝부분만 출력
  - -f : 내용이 추가될때마다 그 부분을 실시간으로 출력

```
tail -f 조회조건

ex) tail -f /data/log/logback/20160914.log | grep 'NullPointerException' | grep 'Member'

```

## 14화 작업 절차를 자동화하고 싶어 (쉘 스크립트)
쉘 작업을 자동화하도록 만든 각본 같은 것 <br/>
* 실제로는 명령어 실행 절차를 작성하면 이를 그대로 실행시켜준다.<br/>
* 파이프라인이 명령어를 옆으로 연결한거라면, 쉘 스크립트는 **명령어를 세로로 연결**한 것 <br/>

작성예)

```
#!/bin/bash
명령어1
명령어2
```

* 제일 첫줄의 ```#!/bin/bash ```는 bash로 아래 명령어들을 실행시키겠다는 의미이다.
* 보통 작성된 쉘 스크립트는 실행 권한이 없으므로 아래처럼 실행권한을 주어야 한다.

```
chmod +x setup.sh
```

* 명령어 실행 도중 실패가 발생할 경우 다음 명령어부터 에러가 계속 발생할 수 있다.
  - 이럴 경우 **에러가 발생하면 그자리에서 바로 실행을 종료** 시키는 코드를 추가하면 된다.
  - 굳이 모든 명령어 라인에 추가할 필요는 없다 (예를 들어 폴더이동 같은경우)
  - 다만, 실패했을 때 그 뒤 처리에 영향이 가는 명령어가 있다면 그다음 줄에 무조건 넣는것이 좋다.

작성예)

```
#!/bin/bash
명령어1
if [ $? != 0 ]; then exit; fi
명령어2
```

## 15화 같은 문자열을 스크립트에서 재사용하고 싶어 (쉘 변수)
일반적으로 우리가 알고 있는 프로그래밍언어의 변수와 동일한 역할을 한다. <br/>
반복적으로 사용하는 값일 경우 변수를 선언 및 할당하여 해당 변수를 사용함으로써 수정이 용이해진다. <br/>

* 기본적인 사용법은 ```변수명=명령어 혹은 값```
  - 해당 변수를 사용하고 싶은 경우엔 ```$변수명```을 사용하면 된다.

```
#!/bin/bash
LOG=/data/log/logback/20160914.log
cat $LOG | grep 'NullPointerException'

```

* 옵션 조합 역시 변수로 할당 할 수 있다.
  - 예를 들어 압축하기/풀기 옵션도 가능하다.

```
#!/bin/bash
TAR_EXTRACT="tar xfv"
TAR_COMPRESS="tar cfv"

#eval을 사용하면 문자열을 명령어처럼 사용가능하다 (Javascript의 eval과 비슷)
eval "$TAR_EXTRACT file.tar.gz"
eval "$TAR_COMPRESS directory"
```
