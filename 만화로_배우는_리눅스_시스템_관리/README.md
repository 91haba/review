# 만화로 배우는 리눅스 시스템 관리 - Prio 지음 / 서수환 옮김 ([Yes24](http://www.yes24.com/24/goods/30705473))

![표지](./images/표지.jpg)

리눅스 환경에서 사용하는 명령어가 너무 단순하고 쓰던것만 쓴다는 생각에 
책 한권을 간단하게라도 훑어 봐야겠다는 생각에 선택한 책 <br/>
생각보다 내용이 알차다 (그만큼 내가 허접하니깐.... 후후..)

![후후...](./images/후후.jpg)

아래 내용은 내가 책의 내용을 주제별로 정리한 것이라 이것만 봐도 되겠지만, 전체 이해를 위해서는 책을 사서 재밌게 읽어보는게 * 10000배 도움된다고 확신한다.

## 1화

## 2화

## 3화

## 4화

## 5화

## 6화

## 7화

## 8화


## 9화 명령어 이력 검색
* 명력어 이력 저장 갯수 수정
```
설정파일 열기 : vim ~/.bashrc
파일끝으로 이동 : shift + g
설정 추가
export HISTSIZE 1000
export HISTFILESIZE=10000
저장 및 반영
source ~/.bashrc
```

* 터미널마다의 명령 히스토리 공유
```
설정파일 열기 : vim ~/.bashrc
파일끝으로 이동 : shift + g
설정 추가
function share_history {
    history -a
    history -c
    history -r
}
PROMPT_COMMAND='share_history'
shopt -u histappend
```

## 10화 네트워크를 건너 파일 복사 (scp)

* 현재 PC의 파일을 반대편 PC로 보내는 경우 : 이쪽에 있는걸 저쪽으로 보낸다는 개념
```
scp 파일명 사용자계정@반대편 PC(네트워크명 또는 IP):복사될 디렉토리 위치

ex) scp ./file.txt jojoldu@192.168.1.10:/tmp/
```

* 반대편 PC의 파일을 현재 PC로 가져올 경우 : 저쪽에 있는걸 이쪽으로 가져온다는 개념
```
scp 사용자계정@반대편 PC(네트워크명 또는 IP):복사할 파일의 위치 현재PC경로(복사될 위치)

ex) scp jojoldu@192.168.1.10:/tmp/file.txt /data/
```

* 여러개 동시 복사
```
1. 와일드카드 사용 (/tmp/ 디렉토리에서 .txt로 끝나는 파일 모두)
ex) scp jojoldu@192.168.1.10:/tmp/*.txt /data/

2. 디렉토리 전체 복사(/tmp/ 디렉토리 전체 복사)
ex) scp -r jojoldu@192.168.1.10:/tmp/ /data/
```

* 다른 PC에서 다른 PC로 파일 복사
```
scp 사용자계정@반대편1:복사파일위치 사용자계정@반대편2:도착디렉토리

ex) scp jojoldu@192.168.1.10:/tmp/file.txt jojoldu@192.168.1.11:/data/
```

## 11화 시스템 부하를 파악하고 싶어 (top)
시스템 부하 관련 정보를 수초 간격으로 실시간으로 갱신파면서 표기해주는 명령어 <br/>
보고 싶은 서버에 접속해서 top만 입력하면 됨 <br/>
아래는 top 명령어로 출력되는 화면에서 확인해야할 내용들이다.

![top 화면](./images/top.png)

* load average 
  - CPU가 처리하는 걸 기다리는 작업 개수
  - CPU는 한 번에 하나밖에 처리 못하니, 그동안 발생한 새로운 작업은 쌓아둔다.
  - load average는 1분당 평균으로 몇 개의 일이 쌓이는지를 나타냄
  - **코어의 수에 따라 load average 부하**정도를 판단해야 한다. (load average >= cpu 코어수 : 과부하 상태)
  - 쿼드코어는 CPU가 4개이므로, 한 번에 4개의 일을 처리하니 load average는 4이하가 안전한 상태이다.
  

* %CPU / TIME+
  - %CPU 란 해당 프로세스사 차지하는 **CPU 사용율**이다.
  - TIME+ 란 실제로 **CPU를 사용한 시간**이다.
  - %CPU가 높아도 TIME+가 짧은 경우 해당 프로세스를 수행하는 시간이 짧고 휴식시간이 긴 형태이므로 실제 부하량은 낮다고 볼 수 있다.
  - 즉, 과부하 원인을 찾을때는 **CPU사용율이 높은지/CPU사용시간이 긴지**로 확인해야 한다.

* COMMAND
  - 프로세스를 실행했을 때 실행한 명령어를 표시
  - 해당 프로세스를 정말 멈춰도 되는지 확인을 위해 주로 본다.
  - top이 켜져있는 상태로 COMMAND의 약자인 "c"를 입력할 경우 상세 커맨드가 표시된다.

## 12화 시스템 메모리 부족을 파악하고 싶어 (top 표시 전환)
CPU 부하량이 낮아도 load average가 높은 경우가 있는데, 대표적인 예가 디스크 I/O이다. <br/>
> 하드디스크에 저장한 파일을 찾거나, 내용을 읽거나, 파일 저장이 끝날때까지 등등의 경우가 있다.

* Swap
  - 스왑 발생량
  - CPU는 메모리에서 작업을 진행하는데, 메모리 여유 공간이 부족하면 새로운 작업을 할 수 없다 (즉, 작업들이 대기시간에 빠진다.)
  - 스왑아웃 : OS에서 메모리 공간 확보를 위해 최근에 사용하지 않은 데이터를 하드디스크로 옮기는 행위
  - 스왑인 : 스왑아웃한 데이터가 필요해지면 하드디스크에서 메모리로 데이터를 되돌리는 행위
  - 스왑아웃 & 스왑인을 합쳐 스왑이라고 한다.
  - **메모리 사용량이 늘면 늘수록 스왑이 빈번하게 발생**해서 I/O 대기시간이 길어지며 load average가 높아지게 된다.
  - Swap가 높으면 스왑 발생량이 높아 load average가 높다는 이야기이다.
  - top의 정렬순서를 변경하고 싶을 경우
    - cpu 시간 순 : shift + t
    - cpu 사용량 순 : shift + p

* %MEM
  - 프로세스가 소비하는 메모리양
  - 전체 메모리 중 해당 프로세스가 몇 %의 메모리를 차지하는지 표시해준다.
  - top의 기본정렬은 CPU부하가 높은 순이라 메모리가 높은 순으로 정렬하고 싶을 경우 shift+m을 누르면 된다.

## 13화 로그 파일에서 필요한 줄만 뽑고 싶어 (파이프라인 |)
명령어의 실행 결과 출력을 그대로 다른 명령어에 넘겨주는 것 (shift+\ 눌렀을 때 나오는 | 를 말함) <br/>
보통은 grep와 함께 사용해서 로그파일에서 여러 조건을 사용한 조회시에 사용한다.

![파이프라인 느낌](./images/파이프라인.png)
(동시에 여러 파이프라인을 사용한 경우 대략 이런 느낌?)

```
출력을 넘기는 명령어 | 출력을 받을 명령어 | 출력을 받을 명령어 | 출력을 받을 명령어

ex) grep 'NullPointerException' /data/log/logback/20160914.log | less
```

* zcat
  - 압축 파일을 읽어서 내용을 풀어서 출력하는 명령어
  - 압축된 log파일을 읽을 때 자주 사용
  - 비슷한 형식으로 zxcat(.xz 압축파일), unzip(zip 압축파일)

* 실시간으로 조건 조회
  - tail : 파일 내용의 끝부분만 출력
  - -f : 내용이 추가될때마다 그 부분을 실시간으로 출력

```
tail -f 조회조건

ex) tail -f /data/log/logback/20160914.log | grep 'NullPointerException' | grep 'Member'

```

## 14화 작업 절차를 자동화하고 싶어 (쉘 스크립트)
쉘 작업을 자동화하도록 만든 각본 같은 것 <br/>
* 실제로는 명령어 실행 절차를 작성하면 이를 그대로 실행시켜준다.<br/>
* 파이프라인이 명령어를 옆으로 연결한거라면, 쉘 스크립트는 **명령어를 세로로 연결**한 것 <br/>

작성예)

```
#!/bin/bash
명령어1
명령어2
```

* 제일 첫줄의 ```#!/bin/bash ```는 bash로 아래 명령어들을 실행시키겠다는 의미이다.
* 보통 작성된 쉘 스크립트는 실행 권한이 없으므로 아래처럼 실행권한을 주어야 한다.

```
chmod +x setup.sh
```

* 명령어 실행 도중 실패가 발생할 경우 다음 명령어부터 에러가 계속 발생할 수 있다.
  - 이럴 경우 **에러가 발생하면 그자리에서 바로 실행을 종료** 시키는 코드를 추가하면 된다.
  - 굳이 모든 명령어 라인에 추가할 필요는 없다 (예를 들어 폴더이동 같은경우)
  - 다만, 실패했을 때 그 뒤 처리에 영향이 가는 명령어가 있다면 그다음 줄에 무조건 넣는것이 좋다.

작성 예)

```
#!/bin/bash
명령어1
if [ $? != 0 ]; then exit; fi
명령어2
```

## 15화 같은 문자열을 스크립트에서 재사용하고 싶어 (쉘 변수)
일반적으로 우리가 알고 있는 프로그래밍언어의 변수와 동일한 역할을 한다. <br/>
반복적으로 사용하는 값일 경우 변수를 선언 및 할당하여 해당 변수를 사용함으로써 수정이 용이해진다. <br/>

* 기본적인 사용법은 ```변수명=명령어 혹은 값```
  - 해당 변수를 사용하고 싶은 경우엔 ```$변수명```을 사용하면 된다.

```
#!/bin/bash
LOG=/data/log/logback/20160914.log
cat $LOG | grep 'NullPointerException'

```

* 옵션 조합 역시 변수로 할당 할 수 있다.
  - 예를 들어 압축하기/풀기 옵션도 가능하다.

```
#!/bin/bash
TAR_EXTRACT="tar xfv"
TAR_COMPRESS="tar cfv"

#eval을 사용하면 문자열을 명령어처럼 사용가능하다 (Javascript의 eval과 비슷)
eval "$TAR_EXTRACT file.tar.gz"
eval "$TAR_COMPRESS directory"
```

* 디렉토리 경로에 변수를 지정할 수도 있다.
```
#!/bin/bash
BASE=/data/log/logback
# $BASE로 써도 되고, ${BASE} 로 써도 되는데 가독성을 위해 ${} 선호
LATEST=${BASE}/access.log
PREV=${BASE}/access.log.7.gz
```

## 16화 작업 환경과 상태를 정해서 스크립트를 실행하고 싶어 (환경 변수)
작업하는 서버에 따라 관리용 사용자 이름이 다를 경우 실행하는 명령어 내용에 사용자명이 추가되어 스크립트 그대로 사용할 수는 없다. <br/>
이럴 경우 사용할 수 있는 것이 환경 변수이다.

* HOME
  - 환경 변수중 HOME은 해당 사용자의 홈 디렉토리 경로가 된다.
  - 예를 들어 ```mkdir ${HOME}/result```라고 지정을 하면 jojoldu 사용자의 서버에서는 ```/home/jojoldu/result``` 디렉토리가 생성되고, jojoldu2사용자의 서버에서는 ```/home/jojoldu2/result``` 디렉토리가 생성된다.

* env
  - 환경 변수 목록

* 자주 사용하는 환경 변수들
  - PWD : 현재 디렉토리 경로
  - EDITOR : 정해진 텍스트 에디터 (vim, Emacs, nano 등) 의 경로
  - PAGER : 정해진 페이저 (less 등)의 경로
  - USER : 현재 사용자의 사용자명
  - GROUP : 현재 사용자의 그룹명
  - HOSTNAME : 머신의 호스트명
  - 굳이 vim이나 less를 직접 지정하지 않는 이유는 각 사용자마다 사용하는 어플리케이션이 다르기 때문

* 명령어 치환
  - result.txt가 매일 생성되며,  이를 날짜별로 파일명을 변경하고 싶을 경우
  - ```mv result.txt result-$(date +%Y-%m-%d),txt``` 로 스크립트를 작성하면 스크립트 실행시마다 오늘의 날짜로 result-yyyy-MM-dd.txt 형식으로 생성된다.
  - date : 오늘의 날짜 
  - %Y : yyyy형식 (yy를 원할 경우 %y)
  - %m : MM형식 (01 ~ 12)
  - %d : dd 형식 (01 ~31)
  - %H : hh 형식 (00 ~ 23)

* $(명령어) vs '명령어'
  - '명령어 '명령어'' 라는 식으로 중첩 명령어 사용시 가독성이 떨어지므로 $(명령어) 사용법 권장
  - 예전에는 '명령어' 밖에 사용하지 못해 호환성문제로 아직 사용하는 경우가 있음

## 17화 로그 파일에서 필요한 줄만 뽑고 싶어 (cut)

* 파이프라인으로 넘어온 내용의 각줄마다 필요한 부분만 잘라내서 넘겨주는 명령어
* 구분자를 이용해 필요한 정보를 구분한다 대표적으로 log 파일에서 스페이스를 구분자로 사용해서 추출하는 경우가 있다.
* 사용법
  - 구분자 지정 : ```-d "구분자"```
  - 추출할 위치 : ```-f 추출할위치``` (구분자로 파싱뒤 몇번째 위치인지)  
* 예를 들어 다음과 같은 Apache(아파치) 로그에서 url 경로를 추출하려면 어떻게 해야할까?
* ```192.168.11.3 - - [12/Feb/2016:15:24:57 +0900] "GET /getUserInfo HTTP/1.1" 200 13472 "-" "Mozilla/5.0 (Windows NT 6.0; rv:17.0) Gecko/20100101 Firefox/17.0"```
* ```cut -d " " -f 7``` 로 하면 스페이스(" ")로 파싱후 7번째 위치인 ```/getUserInfo```를 추출해낼 수 있다.
* 만약 구분자가 쌍따옴표(")인 경우엔 홀따옴표로 감싸면 된다 -> ```cut -d '"' -f 6```  

## 18화 같은 내용의 줄을 세어보고 싶어 (sort와 uniq)

* sort : 내용을 알파벳순으로 재정렬 하는 명령어
* uniq : **이어진 중복**을 제거 한다
  - 즉, 연속되지 않은 경우 중복제거 되지 않는다. 이를 위해 sort를 함께 쓰는 경우가 대부분이다.
  - ```-c``` 옵션을 같이 사용할 경우 중복제거 횟수 확인이 가능하다 (c : count)

* access log에서 같은 url 호출 횟수를 알고 싶을때?
  - ```cat /data/log/nginx/access.log  | cut -d " " -f 7 | sort | uniq -c | less ```  로 하면 ```중복횟수 url``` 로 출력된다.

* 중복횟수 순으로 내림차순 하고 싶을 경우 해당 결과를 다시 파이프라인으로 받아 sort -r (역 정렬) 하면 된다.
  - ```cat /data/log/nginx/access.log  | cut -d " " -f 7 | sort | uniq -c | sort -r| less ```

* 조회수가 가장 많은 5개, 가장 적은 5개 url들만 보고 싶다면?
  - head : 파이프라인을 통해 넘어온 데이터의 **앞부분 10개**를 추출하는 명령어
  - tail : 파이프라인을 통해 넘어온 데이터의 **뒷부분 10개**를 추출하는 명령어
  - 개수 조절을 원한다면 ```-n 갯수``` 옵션을 추가하면 된다.
  - 가장 많은 5개 : ```cat /data/log/nginx/access.log  | cut -d " " -f 7 | sort | uniq -c | sort -r| head -n 5 |less ``` 
  - 가장 적은 5개 : ```cat /data/log/nginx/access.log  | cut -d " " -f 7 | sort | uniq -c | sort -r| tail -n 5 |less ```   

## 19화 CSV 파일을 열의 내용에 따라 정렬하고 싶어 (sort와 >)
예를 들어 csv 파일에서 필요없는 비고는 삭제하고, 재고수로 재정렬 해야 한다면?
* 작업 순서
  - 불필요한 열 제거
  - 줄을 재고수 크기로 재정렬
  - 결과를 파일로 출력하기

* 불필요한 열 제거
  - cut을 활용
  - 1~3 열까지는 사용해야하며, 4열부터는 필요 없다.
  - cut의 ```-f``` 옵션은 뒤에 하나의 숫자만 올수도 있지만, 여러숫자/범위지정 등의 옵션도 가능하다.
  - 여러숫자 : ```-f 1,3,4,6```
  - 범위지정 : ```-f 1-3```  
  - 1~3열까지만 추출 : ```cat items.csv | cut -d "," -f 1-3``` 

* 재고수 크기로 재정렬
  - sort도 cut처럼 구분자로 나누는 기능이 존재
  - 구분자 지정 :  ```-t "구분자"``` 
  - 열 지정 : ```-k 3```
  - 일반적으로 정렬기준시 문자열비교로 앞에서부터 하나씩 비교하기 때문에 숫자의 경우 의도와 다르게 정렬된다. (20, 3이 있을 경우 3이 먼저 된다.)
  - 숫자기준으로 정렬 :  ```-n```
  - 재고수 크기로 재정렬 :  ```sort -t "," -k 3 -n```
  - 앞의 내용과 이어가면 :  ```cat items.csv | cut -d "," -f 1-3 | sort -t "," -k 3 -n | less```

* 결과를 파일로 출력하기
  - ```>``` (리다이렉트) : 명령어 실행 결과를 저장하는 명령어 
  - ```>``` 의 경우 이미 있는 파일은 지우고 새로운 파일 생성
  - ```>>``` 의 경우 기존 파일에 내용 추가
  - 앞의 내용과 이어가면 :   ```cat items.csv | cut -d "," -f 1-3 | sort -t "," -k 3 -n > /data/result.txt```
  
*  tab을 구분자로 쓰기
  - cut 명령어 실행시에는 ```-d```를 지정하지 않으면 기본 구분자가 tab으로 지정된다.
  - 쉘 스크립트내에서는 ```cut -d "탭문자"```로 쓸수 있다. 

## 20화 명령줄 지정으로 작업 내용을 바꾸고 싶어 (명령줄 인수)

* 명령줄 인수 (명령어 인자값 혹은 인수) : 명령어를 실행시킬때 스페이스 단위로 입력하는 값들을 말한다.
  - 예를 들어 ```cat /data/log/nginx/access.log```에서 ```/data/log/nginx/access.log```를 말한다.

* 